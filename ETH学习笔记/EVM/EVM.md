

学习资源
- 官方文档 https://ethereum.org/zh/developers/docs/evm/
- 黄皮书
- ETH问答平台
    - https://ethereum.stackexchange.com/
- EVM Opcodes 参考
    - 简介： 包含所有 EVM 操作码及其对应的 Gas 消耗说明。
    - https://www.ethervm.io/
- 书籍
    - 《Ethereum for Developers》
    - 《Programming Ethereum》
        - Christopher Dannen
- 视频
   - 以太坊解释：以太坊虚拟机（EVM）
      - https://www.bilibili.com/video/BV1aEctetEYc/?spm_id_from=333.337.search-card.all.click&vd_source=9e7f96609fdf67741d9bbf68913badca
   - 区块链从入门到精通 以太坊 EVM 虚拟机简介
      - https://www.bilibili.com/video/BV1Gk4y1v7m7/?spm_id_from=333.337.search-card.all.click&vd_source=9e7f96609fdf67741d9bbf68913badca


以太坊虚拟机 (EVM) 是一个去中心化虚拟环境，它在所有以太坊节点上一种安全一致地方式执行代码。 节点运行以太坊虚拟机，以执行智能合约，利用“燃料”度量执行操作所需的计算工作，从而确保高效的资源分配和网络安全性。




在以太坊虚拟机（EVM）中，“**虚拟机是栈的虚拟机**” 和 “**一次调用产生一个实例**” 这两个说法是理解 EVM 的核心运行机制的关键。下面分别对这两个概念进行详细解释，并讲解“实例”的含义。

---

## **1. EVM 是一个栈的虚拟机**

### **1.1 什么是栈的虚拟机？**
- **栈（Stack）** 是一种后进先出（LIFO，Last In First Out）的数据结构。EVM 使用栈作为主要的运行模型，这意味着所有指令的操作数（Operands）和中间结果都存储在栈上，而不是在寄存器或内存中。
- 在 EVM 中，栈有以下特点：
  1. 栈中存储的是固定大小的 256 位字。
  2. 栈的深度最大为 1024（最多可以存储 1024 个 256 位的值）。
  3. 所有的指令（Operation/Opcode）只能从栈中获取操作数，并将结果写回到栈中。

### **1.2 栈的特性决定了 EVM 的执行流程**
EVM 的每条操作指令（Opcode）必须按照以下流程处理：
1. 从栈中读取操作数。
2. 执行该指令的逻辑。
3. 将计算结果写回到栈中。

#### **栈的操作实例**
例如，假设我们使用 `PUSH` 和 `ADD` 指令构建一个简单的数学计算：

```text
PUSH1 2   (将数字 2 压入栈)
PUSH1 3   (将数字 3 压入栈)
ADD       (将栈顶 2 个数字相加，结果写回栈)
```

- 执行步骤：
  1. 执行 `PUSH1 2`：将 `2` 压入栈，现在栈顶是 `[2]`。
  2. 执行 `PUSH1 3`：将 `3` 压入栈，现在栈是 `[3, 2]`。
  3. 执行 `ADD`：弹出栈顶两个数字 `3` 和 `2`，执行加法得到 `5`，将结果 `5` 压回栈。
     最终栈状态为 `[5]`。

这显示了栈的后进先出的特点：先“压入”操作数，后计算并替换为结果。

---

## **2. 一次调用产生一个实例**

### **2.1 理解 "实例" 的含义**
“实例” 是指在每次合约调用或执行过程中，EVM 会为该次调用创建一个独立的虚拟机运行环境。这意味着，这个“实例”是执行当前调用的**上下文环境**，它包括：
1. **当前执行的字节码**（比如智能合约的字节码）。
2. **执行所需的所有状态信息：**
   - 栈（Stack）：本次调用的栈内容，执行结束后栈被销毁。
   - 内存（Memory）：用于存储临时计算数据的空间，调用结束后清空。
   - 合约存储（Storage）：这是区块链上的永久数据，仅当 `SSTORE` 被更新时发生改变。
3. **调用参数：**
   - 调用函数接收到的输入数据（如函数选择器和参数）。
   - 调用者地址（`msg.sender`）和调用金额（`msg.value`）。
4. **Gas 限制和消耗**（Gas 上限、剩余 Gas 等）。

> 每次 EVM 的合约调用，都会从这些初始信息构建一个独立的“实例”。

#### **实例的作用：**
- 实例负责执行具体一次合约调用或交易的整个过程。
- 调用完成后，该实例就结束生命周期，释放所有临时的数据（栈和内存）。

---

### **2.2 为什么每次调用生成一个独立的实例？**
这是因为 EVM 的设计本质是线程不共享数据的虚拟机，也就是说，每次调用的状态完全隔离，互不干扰。  

1. **隔离性：**
   - 每次实例的堆栈（Stack）、内存（Memory）等是独立的，防止并发运行时的数据污染。
   - 合约之间或函数之间可以自由调用，而不会担心破坏其他调用的上下文。

2. **便于递归调用：**
   - 某些复杂合约调用会产生“嵌套调用”：
     例如，合约 A 调用合约 B，合约 B 再调用合约 C。
   - 每次调用都生成独立的实例，可分别记录并维护每个调用链的上下文。

#### **嵌套调用实例**
假设合约 A 调用合约 B，B 再调用合约 C：
1. EVM 为 A→B 的调用创建了一个实例，称为 `Instance 1`。
2. 当 B 调用 C 时，又创建了新的虚拟机实例，称为 `Instance 2`。
3. 在调用结束后，实例 2 被销毁，返回控制权给实例 1。

---

### **2.3 EVM 中实例的清理与持久化**
- **临时性的数据：**
  - 栈和内存数据在调用结束时被销毁。（临时数据只用于当前调用实例）
- **持久化的数据：**
  - 合约的存储（Storage）被写入区块链，它是跨调用共享的（如果发生 `SSTORE` 操作）。

**总结：**  
每次调用生成独立的实例，是为了保证调用隔离和可靠性，同时使得 EVM 能够高效支持复杂的函数调用链和嵌套调用。

---

### **3. 结合两个概念理解 EVM 的运行背景**
将这两个概念联合起来，可以深入理解 EVM 的运行机制：
1. **栈驱动模型：**
   - 操作码通过栈的形式读取输入和存储结果，操作简单并适合虚拟化处理。
   - EVM 实现了一个 **“基于栈的虚拟计算机”**。

2. **一次调用一个实例：**
   - 每次合约调用（包括嵌套调用）都会生成一个新的虚拟机实例。
   - 这些实例是隔离的，会释放执行过程中的所有临时状态。

结合这些机制，EVM 高效地支持了智能合约执行的核心特点：**去中心化、安全隔离、动态计算和存储**。

---

### **4. 示例：执行一次智能合约调用**
假设我们调用一个简单的智能合约：
```solidity
pragma solidity ^0.8.0;

contract SimpleContract {
    uint256 public value;

    function setValue(uint256 _value) public {
        value = _value;
    }
}
```

- 调用 `setValue(42)`：
1. **产生一次实例：**
   - EVM 为此次调用生成一个独立的虚拟机实例，加载合约字节码。
   - 初始化：
     - 栈为空。
     - 内存为空。
     - 合约存储初始读取。
   - 传递调用数据：
     - 调用参数 `_value=42`，`msg.sender` 指向调用者。

2. **执行指令：**
   - `PUSH` 操作将 `42` 压入栈。
   - `SSTORE` 将 `42` 存储至合约的存储中。

3. **销毁实例：**
   - 调用结束，释放实例的栈和内存。
   - 合约存储中的 `value` 被更新为 `42`，作为持久化状态。

---

### **总结**
- **"栈的虚拟机"**：所有操作指令都在栈上执行，简化了指令的设计和操作数的管理。
- **"调用产生实例"**：每次合约调用都会创建一个独立的虚拟机实例，具有独立的上下文和生命周期，提供数据隔离和弹性支持。
通过这两个特点，EVM 实现了灵活、安全和高效的智能合约执行。



是的，你的理解在很大程度上是正确的，尤其是在以太坊（ETH）以及许多其他区块链网络中，交易的执行确实是串行化的。这是区块链系统为了确保一致性和确定性而采取的设计决策。以下是详细的解释：

---

### **1. 区块链交易的执行是串行的**
在区块链系统中，交易的执行是按照严格的顺序进行的，确保在同一时间点只有一个交易在执行。这种设计的原因包括以下几个方面：

#### **1.1 确保状态的一致性**
- 区块链上的每笔交易都会对链上的“全局状态”（如账户余额、智能合约存储等）进行修改。
- 如果允许并发交易执行，可能会导致状态的不一致。例如：
  - 两笔交易同时试图修改同一个账户的余额，可能会导致数据冲突（类似于传统数据库中的“并发写”问题）。
  - 并发执行可能导致交易的结果依赖于执行顺序（即“非确定性”问题），这在区块链中是不可接受的。

#### **1.2 确保交易的确定性**
- 区块链需要保证所有节点在验证区块时得到完全相同的结果。
- 如果交易是并发执行的，不同节点可能因为执行顺序不同而得到不同的结果，从而破坏共识机制。
- 串行执行交易可以确保在给定的交易顺序下，所有节点的计算结果一致。

#### **1.3 交易的顺序由区块决定**
- 在区块链中，交易是按区块的顺序组织的。
- 每个区块包含一组交易，这些交易是按照矿工（或验证者）在区块中排列的顺序依次执行的。
- 区块链上的状态转换是基于交易的顺序依次进行的，因此不存在并发执行的问题。

---

### **2. 以太坊的交易执行机制**
在以太坊中，EVM（以太坊虚拟机）负责执行交易。每笔交易的执行过程如下：
1. **交易按顺序排列**：
   - 每个区块中的交易是按照矿工（或验证者）设定的顺序排列的。
   - 矿工通常会优先选择 Gas 费较高的交易（即用户支付较高的手续费），并将这些交易按顺序打包到区块中。

2. **逐笔执行交易**：
   - EVM 依次执行每笔交易，并对全局状态进行更新。
   - 当前交易完成后，EVM 的状态会更新为“最新状态”，然后进入下一笔交易的执行。

3. **全局状态的更新**：
   - 每笔交易的执行会修改区块链的“世界状态”（World State），包括账户余额、合约存储等。
   - 交易的执行结果是确定的，且会影响后续交易的执行。例如：
     - 如果某笔交易转移了一些 ETH，那么后续交易的账户余额会基于这笔交易的结果。

#### **示例：交易的顺序影响结果**
假设有两个交易：
- 交易 A：用户 X 向用户 Y 转账 10 ETH。
- 交易 B：用户 Y 向用户 Z 转账 10 ETH。

如果按顺序执行：
1. 交易 A 执行后，用户 Y 的余额增加了 10 ETH。
2. 交易 B 执行时，用户 Y 的余额已经足够，因此交易成功。

如果顺序颠倒：
1. 交易 B 执行时，用户 Y 的余额不足，交易失败。
2. 交易 A 执行后，用户 Y 的余额增加了 10 ETH。

这说明交易的执行顺序直接影响结果，因此必须严格串行执行。

---

### **3. 区块链的“并发性”与“串行性”**
虽然交易的执行是串行的，但区块链系统中的一些其他方面可能涉及并发或并行处理：

#### **3.1 网络层的并发**
- 在区块链网络中，节点之间的交易广播是并发的。
- 交易会被多个节点同时接收和传播，但这些交易的实际执行是由矿工或验证者在打包区块时按顺序排列的。

#### **3.2 区块生成的并发**
- 不同矿工或验证者可能同时生成区块，但最终只有一个区块会被链上的共识机制接受为“主链的一部分”。
- 其他区块会被丢弃或成为孤块（Orphan Block）。

#### **3.3 并行验证**
- 一些区块链（如以太坊 2.0 或其他 PoS 区块链）正在研究如何通过并行验证交易来提高性能。
- 尽管验证可以并行化，但交易的执行仍然需要保持串行化，以确保状态的一致性和结果的确定性。

---

### **4. 特殊场景：跨分片并发（以太坊 2.0 的分片设计）**
在以太坊 2.0 的分片架构中，不同分片上的交易可以并行处理，因为每个分片有自己的状态和交易记录。然而：
- 同一个分片上的交易仍然是串行执行的。
- 跨分片的交易需要通过特定的机制（如跨分片通信）来协调和同步，从而避免状态冲突。

---

### **5. 为什么区块链不支持并发交易？**
区块链选择串行执行交易有以下几个原因：
1. **状态一致性**：
   - 所有节点必须对区块链的状态达成共识。
   - 并发执行可能导致状态不一致，从而破坏共识。

2. **确定性**：
   - 区块链需要确保交易的结果是确定的，任何节点在相同的交易顺序下执行，结果都必须相同。
   - 并发执行容易导致非确定性问题（如竞态条件）。

3. **安全性**：
   - 并发执行可能引入复杂的并发控制问题，增加智能合约开发和验证的难度。
   - 串行执行可以避免许多潜在的安全漏洞（如数据竞争或死锁）。

---

### **6. 总结**
- **区块链的交易执行是串行的**：在同一个时间点，只有一笔交易在执行。
- **原因**：
  1. 确保全局状态的一致性。
  2. 保证交易结果的确定性。
  3. 避免并发引发的安全问题。
- **并发的可能性**：虽然交易执行是串行的，但网络层或未来的分片设计可能引入一定的并发性，但这需要通过复杂的协调机制来确保状态一致性。

因此，在当前主流的区块链（如以太坊）中，可以认为“并发交易”并不存在，所有交易都是按照严格的顺序串行执行的。

