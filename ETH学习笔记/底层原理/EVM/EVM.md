

学习资源
- 官方文档 https://ethereum.org/zh/developers/docs/evm/
- 黄皮书
- ETH问答平台
    - https://ethereum.stackexchange.com/
- EVM Opcodes 参考
    - 简介： 包含所有 EVM 操作码及其对应的 Gas 消耗说明。
    - https://www.ethervm.io/
- 书籍
    - 《Ethereum for Developers》
    - 《Programming Ethereum》
        - Christopher Dannen
- 视频
   - 以太坊解释：以太坊虚拟机（EVM）
      - https://www.bilibili.com/video/BV1aEctetEYc/?spm_id_from=333.337.search-card.all.click&vd_source=9e7f96609fdf67741d9bbf68913badca
   - 区块链从入门到精通 以太坊 EVM 虚拟机简介
      - https://www.bilibili.com/video/BV1Gk4y1v7m7/?spm_id_from=333.337.search-card.all.click&vd_source=9e7f96609fdf67741d9bbf68913badca


以太坊虚拟机 (EVM) 是一个去中心化虚拟环境，它在所有以太坊节点上一种安全一致地方式执行代码。 节点运行以太坊虚拟机，以执行智能合约，利用“燃料”度量执行操作所需的计算工作，从而确保高效的资源分配和网络安全性。




在以太坊虚拟机（EVM）中，“**虚拟机是栈的虚拟机**” 和 “**一次调用产生一个实例**” 这两个说法是理解 EVM 的核心运行机制的关键。下面分别对这两个概念进行详细解释，并讲解“实例”的含义。

---

## **1. EVM 是一个栈的虚拟机**

### **1.1 什么是栈的虚拟机？**
- **栈（Stack）** 是一种后进先出（LIFO，Last In First Out）的数据结构。EVM 使用栈作为主要的运行模型，这意味着所有指令的操作数（Operands）和中间结果都存储在栈上，而不是在寄存器或内存中。
- 在 EVM 中，栈有以下特点：
  1. 栈中存储的是固定大小的 256 位字。
  2. 栈的深度最大为 1024（最多可以存储 1024 个 256 位的值）。
  3. 所有的指令（Operation/Opcode）只能从栈中获取操作数，并将结果写回到栈中。

### **1.2 栈的特性决定了 EVM 的执行流程**
EVM 的每条操作指令（Opcode）必须按照以下流程处理：
1. 从栈中读取操作数。
2. 执行该指令的逻辑。
3. 将计算结果写回到栈中。

#### **栈的操作实例**
例如，假设我们使用 `PUSH` 和 `ADD` 指令构建一个简单的数学计算：

```text
PUSH1 2   (将数字 2 压入栈)
PUSH1 3   (将数字 3 压入栈)
ADD       (将栈顶 2 个数字相加，结果写回栈)
```

- 执行步骤：
  1. 执行 `PUSH1 2`：将 `2` 压入栈，现在栈顶是 `[2]`。
  2. 执行 `PUSH1 3`：将 `3` 压入栈，现在栈是 `[3, 2]`。
  3. 执行 `ADD`：弹出栈顶两个数字 `3` 和 `2`，执行加法得到 `5`，将结果 `5` 压回栈。
     最终栈状态为 `[5]`。

这显示了栈的后进先出的特点：先“压入”操作数，后计算并替换为结果。

---

## **2. 一次调用产生一个实例**

### **2.1 理解 "实例" 的含义**
“实例” 是指在每次合约调用或执行过程中，EVM 会为该次调用创建一个独立的虚拟机运行环境。这意味着，这个“实例”是执行当前调用的**上下文环境**，它包括：
1. **当前执行的字节码**（比如智能合约的字节码）。
2. **执行所需的所有状态信息：**
   - 栈（Stack）：本次调用的栈内容，执行结束后栈被销毁。
   - 内存（Memory）：用于存储临时计算数据的空间，调用结束后清空。
   - 合约存储（Storage）：这是区块链上的永久数据，仅当 `SSTORE` 被更新时发生改变。
3. **调用参数：**
   - 调用函数接收到的输入数据（如函数选择器和参数）。
   - 调用者地址（`msg.sender`）和调用金额（`msg.value`）。
4. **Gas 限制和消耗**（Gas 上限、剩余 Gas 等）。

> 每次 EVM 的合约调用，都会从这些初始信息构建一个独立的“实例”。

#### **实例的作用：**
- 实例负责执行具体一次合约调用或交易的整个过程。
- 调用完成后，该实例就结束生命周期，释放所有临时的数据（栈和内存）。

---

### **2.2 为什么每次调用生成一个独立的实例？**
这是因为 EVM 的设计本质是线程不共享数据的虚拟机，也就是说，每次调用的状态完全隔离，互不干扰。  

1. **隔离性：**
   - 每次实例的堆栈（Stack）、内存（Memory）等是独立的，防止并发运行时的数据污染。
   - 合约之间或函数之间可以自由调用，而不会担心破坏其他调用的上下文。

2. **便于递归调用：**
   - 某些复杂合约调用会产生“嵌套调用”：
     例如，合约 A 调用合约 B，合约 B 再调用合约 C。
   - 每次调用都生成独立的实例，可分别记录并维护每个调用链的上下文。

#### **嵌套调用实例**
假设合约 A 调用合约 B，B 再调用合约 C：
1. EVM 为 A→B 的调用创建了一个实例，称为 `Instance 1`。
2. 当 B 调用 C 时，又创建了新的虚拟机实例，称为 `Instance 2`。
3. 在调用结束后，实例 2 被销毁，返回控制权给实例 1。

---

### **2.3 EVM 中实例的清理与持久化**
- **临时性的数据：**
  - 栈和内存数据在调用结束时被销毁。（临时数据只用于当前调用实例）
- **持久化的数据：**
  - 合约的存储（Storage）被写入区块链，它是跨调用共享的（如果发生 `SSTORE` 操作）。

**总结：**  
每次调用生成独立的实例，是为了保证调用隔离和可靠性，同时使得 EVM 能够高效支持复杂的函数调用链和嵌套调用。

---

### **3. 结合两个概念理解 EVM 的运行背景**
将这两个概念联合起来，可以深入理解 EVM 的运行机制：
1. **栈驱动模型：**
   - 操作码通过栈的形式读取输入和存储结果，操作简单并适合虚拟化处理。
   - EVM 实现了一个 **“基于栈的虚拟计算机”**。

2. **一次调用一个实例：**
   - 每次合约调用（包括嵌套调用）都会生成一个新的虚拟机实例。
   - 这些实例是隔离的，会释放执行过程中的所有临时状态。

结合这些机制，EVM 高效地支持了智能合约执行的核心特点：**去中心化、安全隔离、动态计算和存储**。

---

### **4. 示例：执行一次智能合约调用**
假设我们调用一个简单的智能合约：
```solidity
pragma solidity ^0.8.0;

contract SimpleContract {
    uint256 public value;

    function setValue(uint256 _value) public {
        value = _value;
    }
}
```

- 调用 `setValue(42)`：
1. **产生一次实例：**
   - EVM 为此次调用生成一个独立的虚拟机实例，加载合约字节码。
   - 初始化：
     - 栈为空。
     - 内存为空。
     - 合约存储初始读取。
   - 传递调用数据：
     - 调用参数 `_value=42`，`msg.sender` 指向调用者。

2. **执行指令：**
   - `PUSH` 操作将 `42` 压入栈。
   - `SSTORE` 将 `42` 存储至合约的存储中。

3. **销毁实例：**
   - 调用结束，释放实例的栈和内存。
   - 合约存储中的 `value` 被更新为 `42`，作为持久化状态。

---

### **总结**
- **"栈的虚拟机"**：所有操作指令都在栈上执行，简化了指令的设计和操作数的管理。
- **"调用产生实例"**：每次合约调用都会创建一个独立的虚拟机实例，具有独立的上下文和生命周期，提供数据隔离和弹性支持。
通过这两个特点，EVM 实现了灵活、安全和高效的智能合约执行。



